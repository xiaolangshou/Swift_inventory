1.大数相乘

(Java case通过率为100%)

import java.util.Scanner;

public class Main {
      public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s1 = scanner.next();
        String s2 = scanner.next();
        // 先不做校验。
          int sumLen = s1.length() + s2.length();
          int[] res = new int[sumLen];
          for(int i = 0; i< s1.length(); i++) {
               int num1 = s1.charAt(s1.length() -1 - i ) - '0';
              for(int j  = 0; j< s2.length(); j++) {
                  int num2 = s2.charAt(s2.length() -1 - j) - '0';
                  res[i +j ] += num1 * num2;                         
              }
          }
          for(int i = 0; i< res.length - 1; i++) {
              if(res[i] >= 10) {
                  res[i+1] += res[i] / 10;
                  res[i] %= 10;
              }
          }
          int i = res.length -1;
          for(; i> 0 && res[i] == 0; i--) {} // 去除结果前面的 0
          StringBuilder sb = new StringBuilder();
          for(; i>=0; i--) {
              sb.append(res[i]);
          }
          System.out.println(sb.toString());
 
    }
}

(python case通过率为66.67%)

import sys
s=sys.stdin.readline().strip().split()
def karatsuba_mul(num1, num2):
    #karatsuba算法
    if len(str(num1))==1 or len(str(num2))==1:
        return num1*num2
    n=max(len(str(num1)),len(str(num2)))
    half=n//2
    
    a=num1//10**half
    b=num1%10**half
    c=num2//10**half
    d=num2%10**half
    ac=karatsuba_mul(a,c) #计算a*c
    bd=karatsuba_mul(b,d) #计算b*d
    abcd=karatsuba_mul(a+b,c+d) #计算(a+b)*(c+d)
    adbc=abcd-ac-bd
    return ac*10**(2*half)+adbc*10**half+bd
print(str(karatsuba_mul(int(s[0]), int(s[1]))))


2.从1到n整数中1出现的次数

 (c++)

class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        int count=0;
        long long i=1;
        for(i=1;i<=n;i*=10)
        {
            //i表示当前分析的是哪一个数位
            int a = n/i,b = n%i;
            count=count+(a+8)/10*i+(a%10==1)*(b+1);
        }
        return count;
    }
};

Swift

import Foundation

let str = readLine() ?? ""
let num = Int(str) ?? 0

        func numofOne(_ n: Int) {
            var count = 0
            var i = 1
            var current = 0
            var after = 0
            var before = 0
            
            while n/i != 0 {
                current = (n/i)%10
                before = n/(i*10)
                after = n-(n/i)*i
                //如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数
                if (current == 0) {
                    count += before*i
                }
                //如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1
                else if (current == 1) {
                    count += before * i + after + 1
                }
                //如果大于1,出现1的次数由高位决定,//（高位数字+1）* 当前位数
                else {
                    count += (before + 1) * i
                }
                //前移一位
                i = i*10
            }
            
            print(count)
        }
    
    numofOne(num)


3. 寻找字符串中最长的回文
（python case通过率为100%）

import sys
 
def longestPalindrome(s):
    if s == s[::-1]: return s
    start, maxLen = 0, 1
    for i in range(len(s)):
        if i - maxLen >= 1 and s[i - maxLen -1:i + 1] == s[i - maxLen - 1:i + 1][::-1]:
            start = i - maxLen - 1
            maxLen += 2
            continue
        if i - maxLen >= 0 and s[i - maxLen:i + 1] == s[i - maxLen:i + 1][::-1]:
            start = i - maxLen
            maxLen += 1
    return s[start:start + maxLen]
 
 
for i in sys.stdin.readlines():
    print (longestPalindrome(i.strip()))

(swift case通过率为0)

        let str = readLine()!

        func longestPalindrome(_ s: String) -> String {
            if s.count <= 1 {
                return s
            }
            
            // 1.间隔之间先插入#
            var S = ["#"]
            for c in s {
                S.append(String(c))
                S.append("#")
            }
            
            print(S)
            // 2.遍历找出以每个节点作为轴最长半径
            var maxId: Int = 0
            var max: Int = 0
            var P: [Int] = [1]
            var maxLength: Int = 1
            var maxLengthIndex = 0
            
            for i in 1...S.count - 1 {
                // j是相对于maxId的i的左边的对称点
                let j: Int = maxId - (i - maxId)
                
                if max > i && j >= 0 {
                    P.append(min(P[j], max - i))
                } else {
                    P.append(1)
                }
                // 循环判断以i位置为中心的左右两侧是否相同, 相同加1
                while i + P[i] <= S.count - 1 && i - P[i] >= 0 && S[i + P[i]] == S[i - P[i]] {
                    P[i] += 1
                }
                
                if i + P[i] - 1 > max {
                    // 以i为中心的子回文的最后一个元素的位置
                    max = i + P[i] - 1
                    // 记录i为回文子串的中心id
                    maxId = i
                }
                
                // 判断最长回文的长度,并记录
                if P[i] > maxLength {
                    maxLength = P[i]
                    maxLengthIndex = i
                }
                print("i:\(i) maxId:\(maxId) max:\(max) maxLength:\(maxLength) maxLengthIndex:\(maxLengthIndex) P:\(P)")
            }
            let leftIndex = s.index(s.startIndex, offsetBy: (maxLengthIndex - (maxLength - 1))/2)
            let rightIndex = s.index(leftIndex, offsetBy: maxLength - 1 - 1)
            return String(s[leftIndex...rightIndex])
        }

        print(longestPalindrome(str))
   